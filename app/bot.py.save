import os
import json
import time
import logging
from pathlib import Path
from types import SimpleNamespace
from typing import Dict

from aiogram import Bot, Dispatcher, F, types
from aiogram.enums import ParseMode, ChatType
from aiogram.filters import Command
from aiogram.filters.command import CommandObject
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.client.default import DefaultBotProperties
from aiogram.types import FSInputFile, InlineKeyboardMarkup, InlineKeyboardButton

from dotenv import load_dotenv

# === Local modules ===
from mbti import mbti_from_traits, validate_questions  # —Ç–≤–æ–π —Ñ–∞–π–ª
from keyboards import kb_for_question, kb_after_free, kb_start_test

logging.basicConfig(level=logging.INFO)

# === .env / settings ===
load_dotenv()
settings = SimpleNamespace(
    bot_token=os.getenv("BOT_TOKEN", ""),
    currency=os.getenv("CURRENCY", "XTR").upper(),            # XTR –¥–ª—è Stars
    price_full_report=int(os.getenv("PRICE_FULL_REPORT", "9900")),
    pay_provider_token=os.getenv("PAY_PROVIDER_TOKEN", ""),   # —Ç–æ–∫–µ–Ω –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –¥–ª—è –∫–∞—Ä—Ç
    card_currency=os.getenv("CARD_CURRENCY", "USD").upper(),  # –≤–∞–ª—é—Ç–∞ –¥–ª—è –∫–∞—Ä—Ç
    price_full_report_card=int(os.getenv("PRICE_FULL_REPORT_CARD", os.getenv("PRICE_FULL_REPORT", "9900"))),
)

# --- Fail-fast: –±–µ–∑ —Ç–æ–∫–µ–Ω–∞ –Ω–µ —Å—Ç–∞—Ä—Ç—É–µ–º —è–≤–Ω–æ –∏ –ø–æ–Ω—è—Ç–Ω–æ
if not settings.bot_token:
    raise RuntimeError("BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω –≤ .env")

# === Bot / Dispatcher ===
bot = Bot(
    token=settings.bot_token,
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)
dp = Dispatcher(storage=MemoryStorage())

# === Paths ===
BASE_DIR = Path(__file__).resolve().parent
DATA_DIR = BASE_DIR / "data"
ASSETS_DIR = DATA_DIR / "assets"
IMAGES_DIR = DATA_DIR / "images"

# === Descriptions ===
with open(DATA_DIR / "descriptions_short.json", "r", encoding="utf-8") as f:
    DESCR_SHORT: Dict[str, str] = json.load(f)
with open(DATA_DIR / "descriptions_long.json", "r", encoding="utf-8") as f:
    DESCR_LONG: Dict[str, str] = json.load(f)

# === Questions loader (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã) ===
def load_questions():
    free, paid = [], []
    q_path = DATA_DIR / "questions.json"
    if not q_path.exists():
        raise FileNotFoundError("data/questions.json –Ω–µ –Ω–∞–π–¥–µ–Ω")

    with open(q_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    # –í–∞—Ä–∏–∞–Ω—Ç 1: {"free":[...], "paid":[...]}
    if isinstance(data, dict):
        free = data.get("free") or data.get("FREE") or []
        paid = data.get("paid") or data.get("PAID") or []
    # –í–∞—Ä–∏–∞–Ω—Ç 2: [ {...}, ... ] ‚Äî —Ç–æ–≥–¥–∞ —ç—Ç–æ free, –∞ paid —á–∏—Ç–∞–µ–º –∏–∑ questions_paid.json (–µ—Å–ª–∏ –µ—Å—Ç—å)
    elif isinstance(data, list):
        free = data
        qp = DATA_DIR / "questions_paid.json"
        if qp.exists():
            with open(qp, "r", encoding="utf-8") as pf:
                paid = json.load(pf)
    else:
        raise ValueError("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç questions.json")

    if not isinstance(free, list) or not isinstance(paid, list):
        raise ValueError("–û–∂–∏–¥–∞–ª–∏—Å—å —Å–ø–∏—Å–∫–∏ –≤–æ–ø—Ä–æ—Å–æ–≤ –¥–ª—è free/paid")

    return free, paid

QUESTIONS_FREE, QUESTIONS_PAID = load_questions()
# –í–∞–ª–∏–¥–∞—Ü–∏—è (—Ç–≤–æ—è —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–ø—É—Å–∫–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π —Å –ø–æ–ª—è–º–∏ text/options/trait)
try:
    validate_questions(QUESTIONS_FREE)
    validate_questions(QUESTIONS_PAID)
except Exception as e:
    logging.warning("validate_questions warning: %s", e)

# === Runtime state ===
PAID_USERS: set[int] = set()
LAST_MBTI: dict[int, str] = {}
LAST_FREE_TRAITS: dict[int, list[str]] = {}
LAST_PAID_TRAITS: dict[int, list[str]] = {}

# MBTI Souls (–∞—É—Ä—ã –ø–æ —Å–æ–æ–±—â–µ–Ω–∏—è–º)
AURA_STATE: dict[int, dict[int, dict[str, int]]] = {}

# Persist
STATE_FILE = DATA_DIR / "state.json"

def load_state():
    if STATE_FILE.exists():
        try:
            data = json.load(STATE_FILE.open("r", encoding="utf-8"))
            PAID_USERS.update(data.get("paid_users", []))
            LAST_MBTI.update({int(k): v for k, v in data.get("last_mbti", {}).items()})
            LAST_FREE_TRAITS.update({int(k): v for k, v in data.get("last_free_traits", {}).items()})
            LAST_PAID_TRAITS.update({int(k): v for k, v in data.get("last_paid_traits", {}).items()})
            aura_in = data.get("aura_state", {})
            for chat_id, users in aura_in.items():
                AURA_STATE[int(chat_id)] = {int(uid): udata for uid, udata in users.items()}
            logging.info("State loaded from %s", STATE_FILE)
        except Exception as e:
            logging.warning("Failed to load state: %s", e)

def save_state():
    try:
        json.dump(
            {
                "paid_users": list(PAID_USERS),
                "last_mbti": LAST_MBTI,
                "last_free_traits": LAST_FREE_TRAITS,
                "last_paid_traits": LAST_PAID_TRAITS,
                "aura_state": AURA_STATE,
            },
            STATE_FILE.open("w", encoding="utf-8"),
            ensure_ascii=False,
            indent=2
        )
    except Exception as e:
        logging.warning("Failed to save state: %s", e)

load_state()

# === Anti-spam (—É—Å–∏–ª–µ–Ω) ===
LAST_HIT: dict[int, float] = {}      # user_id -> last time
LAST_CB_HIT: dict[int, float] = {}   # user_id -> last cb time
MIN_INTERVAL = 1.0                   # —Å–µ–∫ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ (–±—ã–ª–æ 0.7)
MIN_CB_INTERVAL = 0.6                # —Å–µ–∫ –Ω–∞ –∫–ª–∏–∫ (–±—ã–ª–æ 0.4)

async def throttle_message(message: types.Message) -> bool:
    now = time.time()
    uid = message.from_user.id
    last = LAST_HIT.get(uid, 0.0)
    if now - last < MIN_INTERVAL:
        return True
    LAST_HIT[uid] = now
    return False

async def throttle_callback(call: types.CallbackQuery) -> bool:
    now = time.time()
    uid = call.from_user.id
    last = LAST_CB_HIT.get(uid, 0.0)
    if now - last < MIN_CB_INTERVAL:
        try:
            await call.answer("–°–µ–∫—É–Ω–¥—É‚Ä¶", cache_time=1)
        except Exception:
            pass
        return True
    LAST_CB_HIT[uid] = now
    return False

# === FSM ===
class FreeTest(StatesGroup):
    answering = State()

class PaidTest(StatesGroup):
    answering = State()

# === Helpers ===
def path_or_none(p: Path) -> FSInputFile | None:
    try:
        if p.exists():
            return FSInputFile(str(p))
    except Exception:
        pass
    return None

# === START ===
@dp.message(Command("start"))
async def cmd_start(message: types.Message, command: CommandObject, state: FSMContext):
    if await throttle_message(message):
        return
    await state.clear()

    # –¥–∏–ø–ª–∏–Ω–∫ –ø–æ—Å–ª–µ –≤–Ω–µ—à–Ω–µ–π –æ–ø–ª–∞—Ç—ã (–µ—Å–ª–∏ —Ç–∞–∫–æ–µ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å)
    if command.args == "access_ok":
        PAID_USERS.add(message.from_user.id)
        save_state()
        await message.answer("–î–æ—Å—Ç—É–ø –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω. –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ç–µ—Å—Ç.")
        await start_paid_block(message.chat.id, state)
        return

    # –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É, –µ—Å–ª–∏ –µ—Å—Ç—å
    start_img = path_or_none(ASSETS_DIR / "start.png")
    caption = (
        "üëã –ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ MBTI-–±–æ—Ç.\n\n"
        "‚Ä¢ –ü—Ä–æ–π–¥–∏ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –∫–æ—Ä–æ—Ç–∫–∏–π —Ç–µ—Å—Ç ‚Äî 16 –≤–æ–ø—Ä–æ—Å–æ–≤.\n"
        "‚Ä¢ –ó–∞—Ç–µ–º –æ—Ç–∫—Ä–æ–π –¥–æ—Å—Ç—É–ø –∫ 20 —É—Ç–æ—á–Ω—è—é—â–∏–º –∏ –ø–æ–ª—É—á–∏ —Ä–∞–∑–≤—ë—Ä–Ω—É—Ç—ã–π –æ—Ç—á—ë—Ç.\n\n"
        "–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤—ã –≤ —á–∞—Ç–µ ‚Äî –±–µ—Å–ø–ª–∞—Ç–Ω–æ: /ice /quiz /whoami /daily /compat /meme\n"
        "–£–Ω–∏–∫–∞–ª—å–Ω–æ: /aura /souls /reflect"
    )
    if start_img:
        await bot.send_photo(message.chat.id, photo=start_img, caption=caption, reply_markup=kb_start_test())
    else:
        await message.answer(caption + "\n\n–ù–∞–∂–º–∏: /test")

@dp.callback_query(F.data == "start_test")
async def cb_start_test(call: types.CallbackQuery, state: FSMContext):
    if await throttle_callback(call):
        return
    await call.answer()
    await start_free_block(call.message.chat.id, state)

@dp.message(Command("test"))
async def cmd_test(message: types.Message, state: FSMContext):
    if await throttle_message(message):
        return
    await start_free_block(message.chat.id, state)

async def start_free_block(chat_id: int, state: FSMContext):
    await state.set_state(FreeTest.answering)
    await state.update_data(idx=0, traits=[])
    await send_free_question(chat_id, state)

async def send_free_question(chat_id: int, state: FSMContext):
    data = await state.get_data()
    idx = data.get("idx", 0)

    if idx >= len(QUESTIONS_FREE):
        # –≤—ã—á–∏—Å–ª—è–µ–º –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π —Ç–∏–ø
        traits: list[str] = data.get("traits", [])
        mbti = mbti_from_traits(traits)

        LAST_FREE_TRAITS[chat_id] = traits
        LAST_MBTI[chat_id] = mbti
        save_state()

        short = DESCR_SHORT.get(mbti, "–ö–æ—Ä–æ—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –≥–æ—Ç–æ–≤–∏—Ç—Å—è.")

        # —ç–∫—Ä–∞–Ω –ø–æ–∫—É–ø–∫–∏ (full.png + –∫–Ω–æ–ø–∫–∏)
        full_img = path_or_none(ASSETS_DIR / "full.png")
        caption = (f"<b>–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π —Ç–∏–ø:</b> <code>{mbti}</code>\n\n"
                   f"{short}\n\n"
                   "üîì –•–æ—á–µ—à—å —Ç–æ—á–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏ —Ä–∞–∑–≤—ë—Ä–Ω—É—Ç—ã–π –æ—Ç—á—ë—Ç?\n"
                   "–û—Ç–∫—Ä–æ–π –¥–æ—Å—Ç—É–ø –∏ –ø—Ä–æ–¥–æ–ª–∂–∏–º —Å 17 –≤–æ–ø—Ä–æ—Å–∞.")
        if full_img:
            await bot.send_photo(chat_id, photo=full_img, caption=caption, reply_markup=kb_after_free(uid=chat_id))
        else:
            await bot.send_message(chat_id, caption, reply_markup=kb_after_free(uid=chat_id))
        await state.clear()
        return

    q = QUESTIONS_FREE[idx]
    options_text = [q["options"][0]["text"], q["options"][1]["text"]]

    image_path = IMAGES_DIR / "free" / f"q{idx+1}.jpg"
    caption = f"<b>–í–æ–ø—Ä–æ—Å {idx+1}/{len(QUESTIONS_FREE)}:</b>\n{q['text']}"

    img = path_or_none(image_path)
    if img:
        await bot.send_photo(chat_id, photo=img, caption=caption, reply_markup=kb_for_question(options_text))
    else:
        await bot.send_message(chat_id, caption, reply_markup=kb_for_question(options_text))

@dp.callback_query(FreeTest.answering, F.data.in_({"opt_0", "opt_1"}))
async def on_answer_free(call: types.CallbackQuery, state: FSMContext):
    if await throttle_callback(call):
        return

    data = await state.get_data()
    idx = data.get("idx", 0)
    q = QUESTIONS_FREE[idx]
    chosen = 0 if call.data == "opt_0" else 1
    trait = q["options"][chosen]["trait"]

    traits: list[str] = data.get("traits", [])
    traits.append(trait)
    await state.update_data(idx=idx + 1, traits=traits)

    try:
        await call.message.delete()
    except Exception:
        pass
    await call.answer()
    await send_free_question(call.message.chat.id, state)

# === –ü–æ–∫—É–ø–∫–∞: –¥–≤–µ –∫–Ω–æ–ø–∫–∏ ‚Äî Stars –∏ Card ===
@dp.callback_query(F.data == "buy_stars")
async def buy_stars(call: types.CallbackQuery):
    if await throttle_callback(call):
        return
    await call.answer()

    prices = [types.LabeledPrice(label="Full MBTI report", amount=settings.price_full_report)]
    await bot.send_invoice(
        chat_id=call.message.chat.id,
        title="–ü–æ–ª–Ω—ã–π MBTI-—Ä–∞–∑–±–æ—Ä",
        description="20 —É—Ç–æ—á–Ω—è—é—â–∏—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ + —Ä–∞–∑–≤—ë—Ä–Ω—É—Ç—ã–π –æ—Ç—á—ë—Ç.",
        payload="full_report_stars",
        provider_token="",          # –¥–ª—è –∑–≤—ë–∑–¥ –ø—É—Å—Ç–æ
        currency="XTR",             # –≤–∞–ª—é—Ç–∞ –∑–≤—ë–∑–¥
        prices=prices,
        max_tip_amount=0,
        need_name=False,
        need_phone_number=False,
        need_email=False,
        need_shipping_address=False,
    )

@dp.callback_query(F.data == "buy_card")
async def buy_card(call: types.CallbackQuery):
    if await throttle_callback(call):
        return
    await call.answer()

    if not settings.pay_provider_token:
        await call.message.answer("üí≥ –û–ø–ª–∞—Ç–∞ –∫–∞—Ä—Ç–æ–π –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ò—Å–ø–æ–ª—å–∑—É–π ¬´üíé –ö—É–ø–∏—Ç—å –∑–∞ –∑–≤—ë–∑–¥—ã¬ª.")
        return

    prices = [types.LabeledPrice(label="Full MBTI report", amount=settings.price_full_report_card)]
    await bot.send_invoice(
        chat_id=call.message.chat.id,
        title="–ü–æ–ª–Ω—ã–π MBTI-—Ä–∞–∑–±–æ—Ä",
        description="20 —É—Ç–æ—á–Ω—è—é—â–∏—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ + —Ä–∞–∑–≤—ë—Ä–Ω—É—Ç—ã–π –æ—Ç—á—ë—Ç.",
        payload="full_report_card",
        provider_token=settings.pay_provider_token,
        currency=settings.card_currency,  # –Ω–∞–ø—Ä. USD/EUR/RUB
        prices=prices,
        max_tip_amount=0,
        need_name=False,
        need_phone_number=False,
        need_email=False,
        need_shipping_address=False,
    )

@dp.pre_checkout_query()
async def process_pre_checkout(pre_checkout_query: types.PreCheckoutQuery):
    await bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True)

@dp.message(F.successful_payment)
async def on_successful_payment(message: types.Message, state: FSMContext):
    uid = message.from_user.id
    PAID_USERS.add(uid)
    save_state()
    await message.answer("‚úÖ –û–ø–ª–∞—Ç–∞ —É—Å–ø–µ—à–Ω–∞! –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å —É—Ç–æ—á–Ω—è—é—â–∏–º–∏ –≤–æ–ø—Ä–æ—Å–∞–º–∏.")
    await start_paid_block(message.chat.id, state)

# === –ü–õ–ê–¢–ù–´–ï 20 ===
class PaidTest(StatesGroup):
    answering = State()

async def start_paid_block(chat_id: int, state: FSMContext):
    await state.set_state(PaidTest.answering)
    await state.update_data(idx=0, traits=[])
    await send_paid_question(chat_id, state)

async def send_paid_question(chat_id: int, state: FSMContext):
    data = await state.get_data()
    idx = data.get("idx", 0)

    if idx >= len(QUESTIONS_PAID):
        paid_traits: list[str] = data.get("traits", [])
        LAST_PAID_TRAITS[chat_id] = paid_traits
        combined = (LAST_FREE_TRAITS.get(chat_id, []) or []) + (paid_traits or [])
        final_mbti = mbti_from_traits(combined)
        LAST_MBTI[chat_id] = final_mbti
        save_state()

        long_text = DESCR_LONG.get(final_mbti)
        if not long_text:
            short = DESCR_SHORT.get(final_mbti, "")
            await bot.send_message(
                chat_id,
                f"<b>–¢–æ—á–Ω—ã–π —Ç–∏–ø:</b> <code>{final_mbti}</code>\n\n"
                f"–ü–æ–∫–∞ –Ω–µ—Ç —Ä–∞–∑–≤—ë—Ä–Ω—É—Ç–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ –¥–ª—è {final_mbti}. –î–µ—Ä–∂–∏ –∫—Ä–∞—Ç–∫–∏–π –≤–∞—Ä–∏–∞–Ω—Ç:\n\n{short}"
            )
        else:
            await bot.send_message(chat_id, f"<b>–¢–æ—á–Ω—ã–π —Ç–∏–ø:</b> <code>{final_mbti}</code>\n\n{long_text}")
        await state.clear()
        return

    q = QUESTIONS_PAID[idx]
    options_text = [q["options"][0]["text"], q["options"][1]["text"]]

    number = 16 + idx + 1  # –Ω—É–º–µ—Ä—É–µ–º 17..36
    image_path = IMAGES_DIR / "paid" / f"q{idx+1}.jpg"
    caption = f"<b>–£—Ç–æ—á–Ω—è—é—â–∏–π {number}/{16 + len(QUESTIONS_PAID)}:</b>\n{q['text']}"

    img = path_or_none(image_path)
    if img:
        await bot.send_photo(chat_id, photo=img, caption=caption, reply_markup=kb_for_question(options_text))
    else:
        await bot.send_message(chat_id, caption, reply_markup=kb_for_question(options_text))

@dp.callback_query(PaidTest.answering, F.data.in_({"opt_0", "opt_1"}))
async def on_answer_paid(call: types.CallbackQuery, state: FSMContext):
    if await throttle_callback(call):
        return

    data = await state.get_data()
    idx = data.get("idx", 0)

    q = QUESTIONS_PAID[idx]
    chosen = 0 if call.data == "opt_0" else 1
    trait = q["options"][chosen]["trait"]

    traits: list[str] = data.get("traits", [])
    traits.append(trait)
    await state.update_data(idx=idx + 1, traits=traits)

    try:
        await call.message.delete()
    except Exception:
        pass
    await call.answer()
    await send_paid_question(call.message.chat.id, state)

# === –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π ¬´—Ä–∞–∑–≤—ë—Ä–Ω—É—Ç—ã–π –æ—Ç—á—ë—Ç¬ª (–¥–ª—è —É–∂–µ –æ–ø–ª–∞—á–∏–≤—à–∏—Ö) ===
@dp.callback_query(F.data == "full_report")
async def send_full_report(call: types.CallbackQuery):
    if await throttle_callback(call):
        return
    await call.answer()
    uid = call.from_user.id
    if uid not in PAID_USERS:
        await call.message.answer("–°–Ω–∞—á–∞–ª–∞ –æ—Ç–∫—Ä–æ–π –¥–æ—Å—Ç—É–ø (–∫–Ω–æ–ø–∫–∞ ¬´–ö—É–ø–∏—Ç—å¬ª).")
        return

    mbti = LAST_MBTI.get(uid)
    if not mbti:
        await call.message.answer("–ù–µ –≤–∏–∂—É —Ç–≤–æ–µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞. –ù–∞—á–Ω–∏ —Å /start –∏ –ø—Ä–æ–π–¥–∏ –∫–æ—Ä–æ—Ç–∫–∏–π —Ç–µ—Å—Ç.")
        return

    long_text = DESCR_LONG.get(mbti)
    if not long_text:
        short = DESCR_SHORT.get(mbti, "")
        await call.message.answer(f"<b>–¢–≤–æ–π —Ç–∏–ø:</b> <code>{mbti}</code>\n\n{short}")
        return
    await call.message.answer(f"<b>–¢–≤–æ–π —Ç–∏–ø:</b> <code>{mbti}</code>\n\n{long_text}")

# ===================== GROUP / FUN (–±–µ—Å–ø–ª–∞—Ç–Ω–æ) =====================
from random import choice as rndchoice
import glob

def _is_group(obj: types.Message | types.CallbackQuery) -> bool:
    chat = obj.message.chat if isinstance(obj, types.CallbackQuery) else obj.chat
    return chat.type in {ChatType.GROUP, ChatType.SUPERGROUP}

@dp.message(Command("whoami"))
async def cmd_whoami(message: types.Message):
    if await throttle_message(message): return
    uid = message.from_user.id
    t = LAST_MBTI.get(uid)
    if not t:
        await message.reply("–Ø –ø–æ–∫–∞ –Ω–µ –∑–Ω–∞—é —Ç–≤–æ–π —Ç–∏–ø. –ù–∞–ø–∏—à–∏ –º–Ω–µ –≤ –õ–°: /start ‚Üí ¬´–ù–∞—á–∞—Ç—å —Ç–µ—Å—Ç¬ª")
        return
    short = DESCR_SHORT.get(t, "")
    await message.reply(f"üë§ <b>{message.from_user.first_name}</b>\n–¢–∏–ø: <code>{t}</code>\n{short[:400]}{'‚Ä¶' if len(short)>400 else ''}")

@dp.message(Command("daily"))
async def cmd_daily(message: types.Message):
    if await throttle_message(message): return
    q = rndchoice([
        "‚òÄÔ∏è –ß—Ç–æ –¥–ª—è —Ç–µ–±—è –∏–¥–µ–∞–ª—å–Ω—ã–π –æ—Ç–¥—ã—Ö?",
        "üß† –ß—Ç–æ –Ω–µ–¥–∞–≤–Ω–æ —É–∑–Ω–∞–ª(–∞), —á—Ç–æ —Ç–µ–±—è —É–¥–∏–≤–∏–ª–æ?",
        "üéØ –ß—Ç–æ —Ö–æ—á–µ—à—å —É—Å–ø–µ—Ç—å –Ω–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ?",
        "üí¨ –ß—Ç–æ —Ç–µ–±—è —Ä–µ–∞–ª—å–Ω–æ –º–æ—Ç–∏–≤–∏—Ä—É–µ—Ç, –∞ —á—Ç–æ ‚Äî –Ω–µ—Ç?",
        "üåç –ú–µ—Å—Ç–æ, –∫—É–¥–∞ —Ö–æ—á–µ—Ç—Å—è –≤–µ—Ä–Ω—É—Ç—å—Å—è?",
        "üìö –ö–Ω–∏–≥–∞/—Ñ–∏–ª—å–º, –∫–æ—Ç–æ—Ä—ã–π –∑–∞—Ü–µ–ø–∏–ª –Ω–µ–¥–∞–≤–Ω–æ?",
        "‚ö° –ö–æ–≥–¥–∞ –Ω—É–∂–µ–Ω —Ñ–æ–∫—É—Å ‚Äî —á—Ç–æ —Ç–µ–±–µ –ø–æ–º–æ–≥–∞–µ—Ç?"
    ])
    await message.reply(f"<b>–í–æ–ø—Ä–æ—Å –¥–Ω—è</b>\n{q}\n\n–û—Ç–≤–µ—Ç—å –∫–æ—Ä–æ—Ç–∫–æ üëá")

ROASTS = {
    "ENTP": ["–í—ã —Å–ø–æ—Ä–∏—Ç–µ –¥–∞–∂–µ —Å —á–∞–π–Ω–∏–∫–æ–º ‚Äî –æ–Ω –∂–µ –Ω–µ–ø—Ä–∞–≤.", "–ú–æ–∑–≥ ‚Äî 120%, –¥–µ–¥–ª–∞–π–Ω—ã ‚Äî –º–∏–Ω—É—Å –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç—å."],
    "ENFP": ["–ò–¥–µ–∏ ‚Äî –æ–∫–µ–∞–Ω, –ø–ª–∞–Ω ‚Äî –ª—É–∂–∏—Ü–∞.", "–í—ã –≤–¥–æ—Ö–Ω–æ–≤–ª—è–µ—Ç–µ –≤—Å–µ—Ö, –∫—Ä–æ–º–µ —Å–≤–æ–µ–≥–æ To-Do."],
    "ISTJ": ["–ü–æ—Ä—è–¥–æ–∫ —É –≤–∞—Å –≤–µ–∑–¥–µ‚Ä¶ –∫—Ä–æ–º–µ —á—É–∂–∏—Ö –≥–æ–ª–æ–≤.", "–°–Ω–∞—á–∞–ª–∞ –ø—Ä–∞–≤–∏–ª–∞, –ø–æ—Ç–æ–º —á—É–≤—Å—Ç–≤–∞. –ò —Ç–∞–∫ –≤—Å–µ–≥–¥–∞."],
    "ISFP": ["¬´–°–¥–µ–ª–∞—é, –∫–æ–≥–¥–∞ –ø–æ—á—É–≤—Å—Ç–≤—É—é¬ª ‚Äî —Ñ–∏—Ä–º–µ–Ω–Ω–∞—è —Ç–∞–∫—Ç–∏–∫–∞.", "–¢–≤–æ—Ä—é –∫—Ä–∞—Å–∏–≤–æ, –¥–µ–¥–ª–∞–π–Ω—ã ‚Äî —ç—Å—Ç–µ—Ç–∏—á–µ—Å–∫–∏ –∏–≥–Ω–æ—Ä–∏—Ä—É—é."]
}
COMPL = {
    "ENTP": ["–í–∏–¥–∏—Ç–µ 10 —Ö–æ–¥–æ–≤ –≤–ø–µ—Ä—ë–¥. –ò —à—É—Ç–∫—É ‚Äî –Ω–∞ 11-–º.", "–í—ã –¥–≤–∏–≥–∞–µ—Ç–µ –æ–±—Å—É–∂–¥–µ–Ω–∏—è —Ç—É–¥–∞, –≥–¥–µ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ."],
    "ENFP": ["–ó–∞–∂–∏–≥–∞–µ—Ç–µ –ª—é–¥–µ–π –∏ –∏–¥–µ–∏ ‚Äî —ç—Ç–æ —Ä–µ–¥–∫–æ—Å—Ç—å.", "–° –≤–∞–º–∏ –∫–æ–º–∞–Ω–¥—ã –æ–∂–∏–≤–∞—é—Ç, –¥–∞–∂–µ —Å–∞–º—ã–µ —Å–∫—É—á–Ω—ã–µ."],
    "ISTJ": ["–ù–∞ –≤–∞—Å –º–æ–∂–Ω–æ –æ–ø–µ—Ä–µ—Ç—å—Å—è. –í—Å–µ–≥–¥–∞.", "–°–∏—Å—Ç–µ–º–Ω–æ—Å—Ç—å, –∫–æ—Ç–æ—Ä–æ–π –º–Ω–æ–≥–∏–º –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç."],
    "ISFP": ["–ß—É–≤—Å—Ç–≤—É–µ—Ç–µ –∫—Ä–∞—Å–æ—Ç—É –∏ –∞—Ç–º–æ—Å—Ñ–µ—Ä—É. –î–µ–ª–∞–µ—Ç–µ —É—é—Ç–Ω–æ.", "–ì–¥–µ –≤—ã ‚Äî —Ç–∞–º —Å—Ç–∏–ª—å –∏ —Ç–µ–ø–ª–æ."]
}

@dp.message(Command("roast"))
async def cmd_roast(message: types.Message):
    if await throttle_message(message): return
    t = LAST_MBTI.get(message.from_user.id)
    if not t:
        await message.reply("–°–Ω–∞—á–∞–ª–∞ —Å–∫–∞–∂–∏ –º–Ω–µ —Å–≤–æ–π —Ç–∏–ø –≤ –õ–° ‚Äî /start ‚Üí ¬´–ù–∞—á–∞—Ç—å —Ç–µ—Å—Ç¬ª")
        return
    line = rndchoice(ROASTS.get(t, ["–°–µ–≥–æ–¥–Ω—è –±–µ–∑ —Ä–æ—É—Å—Ç–∞ ‚Äî —Ç—ã –∏ —Ç–∞–∫ —Ö–æ—Ä–æ—à(–∞)."]))
    await message.reply(f"üî• <b>Roast {t}</b>\n{line}")

@dp.message(Command("compliment"))
async def cmd_compliment(message: types.Message):
    if await throttle_message(message): return
    t = LAST_MBTI.get(message.from_user.id)
    if not t:
        await message.reply("–°–Ω–∞—á–∞–ª–∞ —Å–∫–∞–∂–∏ –º–Ω–µ —Å–≤–æ–π —Ç–∏–ø –≤ –õ–° ‚Äî /start ‚Üí ¬´–ù–∞—á–∞—Ç—å —Ç–µ—Å—Ç¬ª")
        return
    line = rndchoice(COMPL.get(t, ["–¢—ã ‚Äî —Ç–æ—Ç —á–µ–ª–æ–≤–µ–∫, —Å –∫–µ–º —Ö–æ—á–µ—Ç—Å—è –¥–µ–ª–∞—Ç—å –ø—Ä–æ–µ–∫—Ç—ã."]))
    await message.reply(f"üíê <b>{t}</b>\n{line}")

@dp.message(Command("meme"))
async def cmd_meme(message: types.Message):
    if await throttle_message(message): return
    t = LAST_MBTI.get(message.from_user.id)
    if not t:
        await message.reply("–ù–µ –∑–Ω–∞—é —Ç–≤–æ–π —Ç–∏–ø. –ù–∞–ø–∏—à–∏ –º–Ω–µ –≤ –õ–°: /start")
        return
    patt = str(DATA_DIR / "memes" / t / "*")
    files = [p for p in glob.glob(patt) if p.lower().endswith((".jpg",".jpeg",".png",".gif"))]
    if not files:
        await message.reply("–ü–æ–∫–∞ –Ω–µ—Ç –º–µ–º–∞ –¥–ª—è —Ç–≤–æ–µ–≥–æ —Ç–∏–ø–∞. –°–∫–∞–∂–∏ ‚Äî –¥–æ–±–∞–≤–ª—é!")
        return
    try:
        await bot.send_photo(message.chat.id, photo=FSInputFile(rndchoice(files)))
    except Exception:
        await message.reply("–ù–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –º–µ–º, –Ω–æ —è –ø–æ–ø–æ–ª–Ω—é –∫–æ–ª–ª–µ–∫—Ü–∏—é üôà")

# –ú–∏–Ω–∏-–∫–≤–∏–∑ E/I
QUIZ_STATE: dict[int, dict] = {}

@dp.message(Command("quiz"))
async def cmd_quiz(message: types.Message):
    if await throttle_message(message): return
    if not _is_group(message):
        await message.reply("–ö–≤–∏–∑ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ –≥—Ä—É–ø–ø–∞—Ö. –í –õ–° –∂–º–∏ /start.")
        return
    text = "‚ö° –ú–∏–Ω–∏-–∫–≤–∏–∑: —Ç—ã –±–ª–∏–∂–µ –∫‚Ä¶\n‚ë† ¬´–ü–æ–≥–Ω–∞–ª–∏, —Å–¥–µ–ª–∞–µ–º!¬ª\n‚ë° ¬´–î–∞–π—Ç–µ –º–∏–Ω—É—Ç—É –ø–æ–¥—É–º–∞—Ç—å‚Ä¶¬ª"
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚ë† –≠–∫—Å—Ç—Ä–∞–≤–µ—Ä—Ç (E)", callback_data="quiz_e")],
        [InlineKeyboardButton(text="‚ë° –ò–Ω—Ç—Ä–æ–≤–µ—Ä—Ç (I)", callback_data="quiz_i")],
    ])
    sent = await message.reply(text, reply_markup=kb)
    QUIZ_STATE[message.chat.id] = {"msg_id": sent.message_id, "votes": {0:set(),1:set()}}

    import asyncio
    async def close_quiz():
        st = QUIZ_STATE.get(message.chat.id)
        if not st or st["msg_id"] != sent.message_id:
            return
        v0, v1 = len(st["votes"][0]), len(st["votes"][1])
        total = max(1, v0+v1)
        p0, p1 = int(v0*100/total), int(v1*100/total)
        await bot.edit_message_text(
            chat_id=message.chat.id,
            message_id=sent.message_id,
            text=(f"‚úÖ –ò—Ç–æ–≥–∏ –º–∏–Ω–∏-–∫–≤–∏–∑–∞\n"
                  f"E: {v0} ({p0}%) ¬∑ I: {v1} ({p1}%)\n\n"
                  f"–•–æ—á–µ—à—å —Ç–æ—á–Ω—ã–π —Ç–∏–ø? –í –õ–° ‚Äî /start ‚Üí ¬´–ù–∞—á–∞—Ç—å —Ç–µ—Å—Ç¬ª")
        )
    asyncio.get_running_loop().call_later(60, lambda: asyncio.create_task(close_quiz()))

@dp.callback_query(F.data.in_({"quiz_e","quiz_i"}))
async def on_quiz_vote(call: types.CallbackQuery):
    if await throttle_callback(call): return
    if not _is_group(call):
        await call.answer("–ö–≤–∏–∑ ‚Äî —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–µ.")
        return
    st = QUIZ_STATE.get(call.message.chat.id)
    if not st or st["msg_id"] != call.message.message_id:
        await call.answer("–ö–≤–∏–∑ —É–∂–µ –∑–∞–∫—Ä—ã—Ç.")
        return
    uid = call.from_user.id
    pick = 0 if call.data=="quiz_e" else 1
    st["votes"][0].discard(uid); st["votes"][1].discard(uid)
    st["votes"][pick].add(uid)
    v0, v1 = len(st["votes"][0]), len(st["votes"][1])
    await call.answer(f"E: {v0} ¬∑ I: {v1}")

# –õ–µ–¥–æ–∫–æ–ª
ICE_QUESTIONS = [
    ("üì± –°–æ–æ–±—â–µ–Ω–∏—è –Ω–æ—á—å—é –ª—É—á—à–µ‚Ä¶", "–û—Ç–≤–µ—á–∞—Ç—å —Å—Ä–∞–∑—É", "–û—Å—Ç–∞–≤–ª—è—Ç—å –¥–æ —É—Ç—Ä–∞"),
    ("‚òï –£—Ç—Ä–æ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å‚Ä¶", "–ö–æ—Ñ–µ –∏ –ø–ª–∞–Ω—ã", "–¢–∏—à–∏–Ω—ã –∏ –ø—Ä–æ–∫—Ä–∞—Å—Ç–∏–Ω–∞—Ü–∏–∏"),
    ("üéâ –í—ã—Ö–æ–¥–Ω—ã–µ ‚Äî —ç—Ç–æ‚Ä¶", "–î–≤–∏–∂ –∏ –ª—é–¥–∏", "–î–æ–º, —Ñ–∏–ª—å–º—ã, —É—é—Ç"),
    ("‚úàÔ∏è –ü—É—Ç–µ—à–µ—Å—Ç–≤–∏—è:", "–ú–∞—Ä—à—Ä—É—Ç –ø–æ –ø—É–Ω–∫—Ç–∞–º", "–ò–º–ø—Ä–æ–≤–∏–∑–∞—Ü–∏—è –Ω–∞ –º–µ—Å—Ç–µ"),
    ("üß† –°–ø–æ—Ä:", "–í–∞–∂–Ω–æ –±—ã—Ç—å –ø—Ä–∞–≤—ã–º", "–í–∞–∂–Ω–æ –æ—Å—Ç–∞—Ç—å—Å—è –¥—Ä—É–∑—å—è–º–∏"),
]
ICE_STATE: dict[int, dict] = {}

@dp.message(Command("ice"))
async def group_ice(message: types.Message):
    if await throttle_message(message): return
    if not _is_group(message):
        await message.reply("–≠—Ç–æ –¥–ª—è –≥—Ä—É–ø–ø. –í –õ–° ‚Äî /start üôÇ")
        return
    q = rndchoice(ICE_QUESTIONS)
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"‚ë† {q[1]}", callback_data="ice_0")],
        [InlineKeyboardButton(text=f"‚ë° {q[2]}", callback_data="ice_1")],
    ])
    sent = await message.reply(f"üßä <b>–õ–µ–¥–æ–∫–æ–ª</b>\n{q[0]}\n\n–ì–æ–ª–æ—Å—É–µ–º 60 —Å–µ–∫.", reply_markup=kb)
    ICE_STATE[message.chat.id] = {"msg_id": sent.message_id, "q": q, "votes": {0:set(),1:set()}}

    import asyncio
    async def close_poll():
        st = ICE_STATE.get(message.chat.id)
        if not st or st["msg_id"] != sent.message_id:
            return
        v0 = len(st["votes"][0]); v1 = len(st["votes"][1])
        total = max(1, v0+v1); p0 = int(v0*100/total); p1 = int(v1*100/total)
        await bot.edit_message_text(
            chat_id=message.chat.id, message_id=sent.message_id,
            text=(f"üßä <b>–ò—Ç–æ–≥–∏ –ª–µ–¥–æ–∫–æ–ª–∞</b>\n{q[0]}\n\n"
                  f"‚ë† {q[1]} ‚Äî <b>{v0}</b> ({p0}%)\n"
                  f"‚ë° {q[2]} ‚Äî <b>{v1}</b> ({p1}%)\n\n"
                  f"–•–æ—á–µ—à—å —É–∑–Ω–∞—Ç—å —Å–≤–æ–π —Ç–∏–ø? –í –õ–° ‚Äî /start ‚Üí ¬´–ù–∞—á–∞—Ç—å —Ç–µ—Å—Ç¬ª")
        )
    asyncio.get_running_loop().call_later(60, lambda: asyncio.create_task(close_poll()))

@dp.callback_query(F.data.in_({"ice_0","ice_1"}))
async def on_ice_vote(call: types.CallbackQuery):
    if await throttle_callback(call): return
    if not _is_group(call):
        await call.answer("–≠—Ç–æ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Ö.")
        return
    st = ICE_STATE.get(call.message.chat.id)
    if not st or st["msg_id"] != call.message.message_id:
        await call.answer("–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ.")
        return
    uid = call.from_user.id
    pick = 0 if call.data=="ice_0" else 1
    st["votes"][0].discard(uid); st["votes"][1].discard(uid)
    st["votes"][pick].add(uid)
    v0 = len(st["votes"][0]); v1 = len(st["votes"][1])
    await call.answer(f"–ü—Ä–∏–Ω—è—Ç–æ! ‚ë† {v0} ¬∑ ‚ë° {v1}")

# –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å (–ø–æ —Ä–µ–ø–ª–∞—é)
@dp.message(Command("compat"))
async def group_compat(message: types.Message):
    if await throttle_message(message): return
    if not _is_group(message):
        await message.reply("–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –≥—Ä—É–ø–ø. –í –õ–° ‚Äî /start.")
        return
    if not message.reply_to_message:
        await message.reply("–û—Ç–≤–µ—Ç—å —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–æ–π –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ–ª–æ–≤–µ–∫–∞ (—Ä–µ–ø–ª–∞–π).")
        return
    uid1 = message.from_user.id
    uid2 = message.reply_to_message.from_user.id
    t1 = LAST_MBTI.get(uid1); t2 = LAST_MBTI.get(uid2)
    if not t1 or not t2:
        await message.reply("–£ –∫–æ–≥–æ-—Ç–æ –Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞. –í –õ–° ‚Äî /start ‚Üí ¬´–ù–∞—á–∞—Ç—å —Ç–µ—Å—Ç¬ª")
        return

    def score(a: str, b: str) -> int:
        s = 0
        s += 1 if a[1]==b[1] else 0
        s += 1 if a[2]==b[2] else 0
        s += 1 if a[0]!=b[0] else 0
        s += 1 if a[3]!=b[3] else 0
        return s
    sc = score(t1,t2)
    labels = {0:"‚ö†Ô∏è —Å–ø–æ—Ä–Ω–æ",1:"üü° —Ç–∞–∫ —Å–µ–±–µ",2:"üü† –∑–∞–≤–∏—Å–∏—Ç",3:"üü¢ —Ö–æ—Ä–æ—à–æ",4:"üíö –æ—á–µ–Ω—å —Ö–æ—Ä–æ—à–æ"}
    await message.reply(
        f"üíû –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å:\n"
        f"{message.from_user.first_name}: <code>{t1}</code>\n"
        f"{message.reply_to_message.from_user.first_name}: <code>{t2}</code>\n"
        f"–û—Ü–µ–Ω–∫–∞: <b>{labels[sc]}</b> ({sc}/4)\n"
        f"–ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ —Å–æ–≤–µ—Ç—ã ‚Äî –≤ –õ–° –ø–æ—Å–ª–µ –ø–ª–∞—Ç–Ω–æ–≥–æ –±–ª–æ–∫–∞."
    )

# =============== MBTI SOULS: –∞—É—Ä–∞ / –∞—Ä—Ö–µ—Ç–∏–ø—ã / –∞–Ω–∞–ª–∏–∑ ===============
def _text_features(s: str) -> dict[str, int]:
    emojis = sum(1 for ch in s if ord(ch) > 0x1F000 or ch in "üòÇüòÖü§£üòç‚ù§Ô∏èüî•‚ú®üòéüòâüôÇüôÉü§îüò≠üò¥üéâ")
    exc = s.count("!")
    qmark = s.count("?")
    length = len(s)
    lower = s.lower()

    logic_words = sum(lower.count(w) for w in ["–ø–æ—Ç–æ–º—É", "–µ—Å–ª–∏", "–ø–æ—ç—Ç–æ–º—É", "–ª–æ–≥–∏—á", "—Ñ–∞–∫—Ç"])
    feel_words  = sum(lower.count(w) for w in ["—á—É–≤—Å—Ç–≤", "–∫–∞–∂–µ—Ç—Å—è", "—ç–º–æ—Ü", "–Ω—Ä–∞–≤", "–¥—É—à"])
    plan_words  = sum(lower.count(w) for w in ["–ø–ª–∞–Ω", "—Å—Ä–æ–∫", "–¥–µ–¥–ª–∞–π–Ω", "—á–µ–∫–ª–∏—Å—Ç", "—Å—Ç—Ä—É–∫—Ç"])
    flow_words  = sum(lower.count(w) for w in ["—Å–≤–æ–±–æ–¥", "–∏–º–ø—Ä–æ–≤", "—ç–∫—Å–ø–µ—Ä–∏–º", "–∫–∞–∫ –ø–æ–π–¥—ë—Ç"])

    score = {"E":0,"I":0,"N":0,"S":0,"T":0,"F":0,"J":0,"P":0}
    if emojis + exc >= 2 or (length < 60 and emojis + exc >= 1):
        score["E"] += 2
    if qmark >= 2 or length > 120:
        score["I"] += 1
    if "–∏–¥–µ" in lower or "—Å–º—ã—Å–ª" in lower or "–ø–∞—Ç—Ç–µ—Ä" in lower: score["N"] += 2
    if "—Ñ–∞–∫—Ç" in lower or "–ø—Ä–∞–∫—Ç–∏–∫" in lower or "–ø—Ä–∏–º–µ—Ä" in lower: score["S"] += 2
    score["T"] += logic_words
    score["F"] += feel_words
    score["J"] += plan_words
    score["P"] += flow_words

    return {"cnt":1, "chars":length, "emoji":emojis, "exc":exc, "qmark":qmark, **score}

def _merge_feat(dest: dict[str,int], add: dict[str,int]) -> None:
    for k,v in add.items(): dest[k] = dest.get(k,0) + v

def _dominant_type_feat(d: dict[str,int]) -> str:
    e = "E" if d.get("E",0) >= d.get("I",0) else "I"
    n = "N" if d.get("N",0) >= d.get("S",0) else "S"
    t = "T" if d.get("T",0) >= d.get("F",0) else "F"
    j = "J" if d.get("J",0) >= d.get("P",0) else "P"
    return f"{e}{n}{t}{j}"

def _arch_name(mbti: str) -> str:
    ARCHETYPES = {
        "ENFP": "–í–¥–æ—Ö–Ω–æ–≤–∏—Ç–µ–ª—å üåà", "ENFJ": "–ö–æ—É—á üí¨", "ENTP": "–ò—Å–∫—Ä–∞ ‚ö°", "ENTJ": "–ü–æ–ª–∫–æ–≤–æ–¥–µ—Ü üß≠",
        "ESFP": "–®–æ—É–º–µ–Ω üé≠", "ESFJ": "–•–æ—Å—Ç üíé", "ESTP": "–î—Ä–∞–π–≤–µ—Ä üèé", "ESTJ": "–ú–µ–Ω–µ–¥–∂–µ—Ä üìä",
        "INFP": "–ú–µ—á—Ç–∞—Ç–µ–ª—å üåô", "INFJ": "–ù–∞–≤–∏–≥–∞—Ç–æ—Ä üîÆ", "INTP": "–ú—ã—Å–ª–∏—Ç–µ–ª—å üß†", "INTJ": "–°—Ç—Ä–∞—Ç–µ–≥ ‚ôü",
        "ISFP": "–ê—Ä—Ç–∏—Å—Ç üé®", "ISFJ": "–û–ø–µ–∫—É–Ω ü´∂", "ISTP": "–ú–∞—Å—Ç–µ—Ä üîß", "ISTJ": "–°—Ç–∞–±–∏–ª–∏–∑–∞—Ç–æ—Ä üß±"
    }
    return ARCHETYPES.get(mbti, "–ê—Ä—Ö–µ—Ç–∏–ø")

@dp.message(F.chat.type.in_({ChatType.GROUP, ChatType.SUPERGROUP}), ~F.text.startswith("/"))
async def collect_aura(message: types.Message):
    if not message.text:
        return
    chat_id = message.chat.id
    uid = message.from_user.id
    feats = _text_features(message.text)
    chat_map = AURA_STATE.setdefault(chat_id, {})
    u = chat_map.setdefault(uid, {})
    _merge_feat(u, feats)
    if (u.get("cnt",0) % 10) == 0:
        save_state()

@dp.message(Command("aura"))
async def cmd_aura(message: types.Message):
    if await throttle_message(message): return
    chat_id = message.chat.id
    uid = message.from_user.id
    u = AURA_STATE.get(chat_id, {}).get(uid)
    if not u:
        await message.reply("–ü–æ–∫–∞ –º–∞–ª–æ –¥–∞–Ω–Ω—ã—Ö –ø–æ —Ç–≤–æ–µ–π –∞—É—Ä–µ. –ü–∏—à–∏ —á–∞—â–µ, –∏ —è –ø–æ–∫–∞–∂—É –∫–∞—Ä—Ç–∏–Ω—É üòâ")
        return
    inferred = _dominant_type_feat(u)
    known = LAST_MBTI.get(uid)
    drift = f"–î—Ä–µ–π—Ñ: <code>{known}</code> ‚Üí <code>{inferred}</code>\n" if known and known != inferred else ""
    arche = _arch_name(inferred)
    total = u.get("cnt",0); emojis = u.get("emoji",0); exc = u.get("exc",0); qm = u.get("qmark",0); chars = u.get("chars",0)
    await message.reply(
        "üåå <b>–¢–≤–æ—è –∞—É—Ä–∞</b>\n"
        f"–ê—Ä—Ö–µ—Ç–∏–ø: <b>{arche}</b> (<code>{inferred}</code>)\n"
        f"{drift}"
        f"–°–æ–æ–±—â–µ–Ω–∏–π: <b>{total}</b>, —Å–∏–º–≤–æ–ª–æ–≤: <b>{chars}</b>\n"
        f"–≠–º–æ–¥–∑–∏: {emojis} ¬∑ !: {exc} ¬∑ ?: {qm}\n"
        "–ü–∏—à–∏ –µ—â—ë ‚Äî –∞—É—Ä–∞ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –ø–æ –º–µ—Ä–µ –æ–±—â–µ–Ω–∏—è."
    )

@dp.message(Command("souls"))
async def cmd_souls(message: types.Message):
    if await throttle_message(message): return
    chat_id = message.chat.id
    users = AURA_STATE.get(chat_id, {})
    if not users:
        await message.reply("–Ø –µ—â—ë –Ω–µ —Å–æ–±—Ä–∞–ª –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –ø–æ —á–∞—Ç—É.")
        return
    counts: Dict[str,int] = {}
    for uid, feats in users.items():
        t = _dominant_type_feat(feats)
        counts[t] = counts.get(t,0) + 1
    top = sorted(counts.items(), key=lambda kv: kv[1], reverse=True)[:10]
    lines = [f"{_arch_name(t)} ‚Äî <b>{c}</b>" for t,c in top]
    await message.reply("üó∫ <b>–ö–∞—Ä—Ç–∞ –∞—Ä—Ö–µ—Ç–∏–ø–æ–≤ —á–∞—Ç–∞</b>\n" + "\n".join(lines))

@dp.message(Command("reflect"))
async def cmd_reflect(message: types.Message):
    if await throttle_message(message): return
    target_text = None
    user_name = message.from_user.first_name
    if message.reply_to_message and message.reply_to_message.text:
        target_text = message.reply_to_message.text
        user_name = message.reply_to_message.from_user.first_name
    elif message.text and len(message.text.split(maxsplit=1)) > 1:
        target_text = message.text.split(maxsplit=1)[1]
    if not target_text:
        await message.reply("–û—Ç–ø—Ä–∞–≤—å /reflect –≤ –æ—Ç–≤–µ—Ç –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ ‚Äî —è –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É—é —Ç–æ–Ω –∏ ¬´—ç–Ω–µ—Ä–≥–∏—é¬ª.")
        return
    fts = _text_features(target_text)
    t = _dominant_type_feat(fts)
    vibe = []
    if fts["emoji"] + fts["exc"] >= 2: vibe.append("—ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ")
    if fts["qmark"] >= 2: vibe.append("–≤–æ–ø—Ä–æ—Å–∏—Ç–µ–ª—å–Ω–æ/—Ä–µ—Ñ–ª–µ–∫—Å–∏–≤–Ω–æ")
    if fts["T"] > fts["F"]: vibe.append("–ª–æ–≥–∏—á–Ω–æ")
    if fts["F"] > fts["T"]: vibe.append("—ç–º–ø–∞—Ç–∏—á–Ω–æ")
    if fts["J"] > fts["P"]: vibe.append("—Å—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ")
    if fts["P"] > fts["J"]: vibe.append("–∏–º–ø—Ä–æ–≤–∏–∑–∞—Ü–∏–æ–Ω–Ω–æ")
    vibe_txt = ", ".join(vibe) if vibe else "–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ"
    await message.reply(f"‚ú¥Ô∏è <b>–≠—Ö–æ –ª–∏—á–Ω–æ—Å—Ç–∏</b>\n{user_name} –∑–≤—É—á–∏—Ç –∫–∞–∫ <code>{t}</code> ‚Äî {vibe_txt}.\n–•–æ—á–µ—à—å —Ç–æ—á–Ω–µ–µ? –í –õ–° ‚Äî /start.")

# === main ===
async def main() -> None:
    await dp.start_polling(bot)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
